## State in Compose

- State in Compose
    - State determines what is shown in the UI at any particular time.
    - Provide a default Modifier to all composable functions
        - As it increases reusablility.
        - It should appear as **the** **first optional parameter, after all required parameters**.
- Events in Compose
    - State *is*. Events *happen*. (상태는 “존재”하고, 이벤트는 “발생”한다.)
    - Event → Update State → Display State → Event…
        - Event - An event is generated by the user or another part of the program.
        - Update State - An event handler changes the state that is used by the UI.
        - Display State - The UI is updated to display the new state.
- Memory in a composable function
    - **The Composition:** a description of the UI built by Jetpack Compose when it executes composables.
    - **Initial composition:** creation of a Composition by running composables the first time.
    - **Recomposition:** re-running composables to update the Composition when data changes.
    - `mutableStateOf` function to create an observable MutableState.
    - Using `remember` as a mechanism to store a single object in the Composition, in the same way a private val property does in an object.
- Restore state in Compose
    - Use `rememberSaveable` to restore your UI state after an Activity or process is recreated.
    - Besides retaining state across recompositions, `rememberSaveable` also retains state across Activity and process recreation.
- State hoisting
    - The pattern where the state goes down, and events go up is called Unidirectional Data Flow (UDF), and state hoisting is how we implement this architecture in Compose.
    - **Single source of truth**: By moving state instead of duplicating it, we're ensuring there's only one source of truth. This helps avoid bugs.
    - **Shareable**: Hoisted state can be shared with multiple composables.
    - **Interceptable**: Callers to the stateless composables can decide to ignore or modify events before changing the state.
    - **Decoupled**: The state for a stateless composable function can be stored anywhere. For example, in a ViewModel.
    - Stateful vs Stateless
        - A **stateless** composable is a composable that doesn't own any state, meaning it doesn't hold or define or modify new state.
        - A **stateful** composable is a composable that owns a piece of state that can change over time.
        - In real apps, having a 100% stateless composable can be difficult to achieve depending on the composable's responsibilities.
        - You should design your composables in a way that they will own as little state as possible and allow the state to be hoisted, when it makes sense, by exposing it in the composable's API.
    
    **Key Point:** When hoisting state, there are three rules to help you figure out where state should go:
    
    1. State should be hoisted to at *least* the **lowest common parent** of all composables that use the state (read).
    2. State should be hoisted to at *least* the **highest level it may be changed** (write).
    3. If **two states change in response to the same events** they should be **hoisted to the same level.**
    
    You can hoist the state higher than these rules require, but if you don't hoist the state high enough, it might be difficult or impossible to follow unidirectional data flow.
    
    **Key Point:** A best practice for the design of Composables is to pass them only the parameters they need.
    
