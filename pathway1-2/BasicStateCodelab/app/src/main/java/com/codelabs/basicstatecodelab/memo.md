
Compose : 선언형 UI 프레임워크
Composition : 컴포저블을 실행할 때 Jetpack Compose에서 빌드한 UI에 관한 설명입니다.
Initial Composition : 처음 컴포저블을 실행하여 컴포지션을 만듭니다.
Recomposition : 데이터가 변경될 때 컴포지션을 업데이트하기 위해 컴포저블을 다시 실행하는 것을 말합니다.

어떻게 업데이트 타이밍을 아는가?
-> Compose 가 추적할 상태를 알아야한다. 그래야 업데이트 받을 때 리컴포지션 가능
추적할 상태는 State 와 MutableState 유형을 사용
value 속성을 읽는 각 Composable 을 추적하고 그 value 가 변경 되면 리컴포지션 트리거하는 방식

어떻게 리컴포지션 간에 데이터를 유지하는가?
-> remember 를 사용
remember는 컴포지션에 객체를 저장하고, remember가 호출되는 소스 위치가 리컴포지션 중에 다시 호출되지 않으면 객체를 삭제
remember를 사용하면 리컴포지션 간에 상태를 유지하는 데 도움이 되지만 구성 변경 간에는 유지안됨. 이를 위해서는 remember 대신 rememberSaveable을 사용

- remember 를 사용하는 컴포저블은 내부상태가 포함되어있으므로 Stateful. (반대가 Stateless) 
  - 장 : 호출자가 상태를 직접 관리하지 않아도 된다면 유용
  - 단 : 재사용 가능성이 적고, 테스트하기 더 어렵게함

- 상태 호이스팅
  - Composable 을 Stateless 로 만들기 위해 상태를 호출자로 옮기는 패턴.
  - 일반적으로 value: T 와 onValueChange: (T) -> Unit 을 매개변수로 바꾸는 패턴이 있음.
  - Composable 에서 UDF (단방향 데이터 흐름) 을 구현하는 방법




기본적으로 각 항목의 상태는 목록에 있는 항목의 위치를 기준으로 키가 지정됩니다.

변경 가능한 목록에서는 데이터 세트가 변경될 때 문제가 발생합니다. 위치를 변경하는 항목은 기억된 상태를 사실상 잃기 때문입니다.

ViewModel은 탐색 그래프의 활동이나 프래그먼트, 대상에서 호출되는 루트 컴포저블에 가까운 화면 수준 컴포저블에서 사용하는 것이 좋습니다. ViewModel은 다른 컴포저블로 전달하면 안 됩니다. 대신 필요한 데이터와 필수 로직을 실행하는 함수만 매개변수로 전달해야 합니다.


리스트 변경
- MutableList를 위해 추적하는 것이 요소 추가 및 삭제와 관련된 변경사항
- 체크는 state 가 아니어서 인식하지 못하는 문제가 있었다.
- copy vs 체크변수를 mutableState 로 만들기
